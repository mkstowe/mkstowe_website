{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nexport let VariegataPost5Component = /*#__PURE__*/(() => {\n  class VariegataPost5Component {\n    constructor(titleService) {\n      this.titleService = titleService;\n      this.titleService.setTitle(\"Michael Stowe | Project Variegata\");\n    }\n    ngOnInit() {}\n  }\n  VariegataPost5Component.ɵfac = function VariegataPost5Component_Factory(t) {\n    return new (t || VariegataPost5Component)(i0.ɵɵdirectiveInject(i1.Title));\n  };\n  VariegataPost5Component.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: VariegataPost5Component,\n    selectors: [[\"app-variegata-post5\"]],\n    decls: 55,\n    vars: 0,\n    consts: [[1, \"content\"], [1, \"is-bold\"], [1, \"seg\"], [1, \"blog_topic\"], [\"href\", \"https://snap.stanford.edu/node2vec/\", \"target\", \"_blank\"], [\"href\", \"https://towardsdatascience.com/introduction-to-word-embedding-and-word2vec-652d0c2060fa\", \"target\", \"_blank\"], [\"href\", \"../../../assets/static-pages/variegata-example2.html\", \"target\", \"_blank\"]],\n    template: function VariegataPost5Component_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"h2\", 1);\n        i0.ɵɵtext(2, \"March 10, 2021\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"h3\", 3)(5, \"strong\");\n        i0.ɵɵtext(6, \"Progress So Far\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(7, \"p\");\n        i0.ɵɵtext(8, \"This week was spent getting the first iteration of the actual story generator up and running. It's rough, but it's something!\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"p\");\n        i0.ɵɵtext(10, \"The main technologies used for this step include:\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"ul\")(12, \"li\");\n        i0.ɵɵtext(13, \"Python/Flask\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"li\");\n        i0.ɵɵtext(15, \"node2vec\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(16, \"div\", 2)(17, \"h3\", 3)(18, \"strong\");\n        i0.ɵɵtext(19, \"The Model\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(20, \"p\");\n        i0.ɵɵtext(21, \"The biggest challenge of this iteration was getting the initial model to behave as expected. I did a lot of research on different approaches to graph-based machine learning, and ultimately settled on \");\n        i0.ɵɵelementStart(22, \"a\", 4);\n        i0.ɵɵtext(23, \"node2vec\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(24, \" as the main algorithm. This is a variation of the \");\n        i0.ɵɵelementStart(25, \"a\", 5);\n        i0.ɵɵtext(26, \"word2vec\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(27, \" family of algorithms that is most commonly used for text prediction applications. Node2vec abstracts this idea in order to work on general graphs. It allows us to be able to embed new nodes into a graph based on the sequences it generates by performing random walks on the graph.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(28, \"p\");\n        i0.ɵɵtext(29, \"In the context of this project, what it means is that by inputting an arbitrary number of story graphs (where nodes represent events in the story), we can train a model to tell us which nodes - or events - are most similar to the one we are currently on.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(30, \"div\", 2)(31, \"h3\", 3)(32, \"strong\");\n        i0.ɵɵtext(33, \"The Generator\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(34, \"p\");\n        i0.ɵɵtext(35, \"Using our trained model, we can generate new stories! Currently, the model is only trained on the labels of the nodes, and not the actual content associated with them. This means that the generator can only create a story using events existing within one story at a time - it cannot merge stories together. The way it works is we choose a random event from our master list of events created when scraping stories, we then give this event to our model, and it gives us a list of events that are most similar to the current event.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(36, \"p\");\n        i0.ɵɵtext(37, \"When choosing which node to link to next from the list of similar nodes, it may be tempting to always pick the one that is \");\n        i0.ɵɵelementStart(38, \"em\");\n        i0.ɵɵtext(39, \"most\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(40, \" similar. However, this can cause some issues. Since our story graphs are bidirectional - meaning an action can move us to forward or backward in terms of events - two nodes can link to each other and cause an endless loop. If we reach one of these and always choose the most similar node to be next, we could end up just moving back and forth between these events indefinitely. To solve this, our generator will pick a random node among the five most similar nodes returned. This way, there are more opportunities to get out of these event loops.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(41, \"p\");\n        i0.ɵɵtext(42, \"For now, the generator creates a story consisting of ten events. There is not much user interactivity involved, but this will change in future iterations.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(43, \"div\", 2)(44, \"p\");\n        i0.ɵɵtext(45, \"Finally, you can see an \");\n        i0.ɵɵelementStart(46, \"a\", 6);\n        i0.ɵɵtext(47, \"example story\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(48, \" created by this iteration of the generator.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(49, \"div\", 2)(50, \"h3\", 3)(51, \"strong\");\n        i0.ɵɵtext(52, \"Moving Forward\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(53, \"p\");\n        i0.ɵɵtext(54, \"For the next iteration, I plan on training the model on the content of the events rather than labels so that it can create stories with a much larger pool of events - likely by breaking events down into keywords and creating subgraphs from those. Additionally, I hope to get actions working so that it's more like the text adventures, and less a wall of text.\");\n        i0.ɵɵelementEnd()()();\n      }\n    }\n  });\n  return VariegataPost5Component;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}