{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nexport let VariegataPost8Component = /*#__PURE__*/(() => {\n  class VariegataPost8Component {\n    constructor(titleService) {\n      this.titleService = titleService;\n      this.titleService.setTitle(\"Michael Stowe | Project Variegata\");\n    }\n    ngOnInit() {}\n  }\n  VariegataPost8Component.ɵfac = function VariegataPost8Component_Factory(t) {\n    return new (t || VariegataPost8Component)(i0.ɵɵdirectiveInject(i1.Title));\n  };\n  VariegataPost8Component.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: VariegataPost8Component,\n    selectors: [[\"app-variegata-post8\"]],\n    decls: 42,\n    vars: 0,\n    consts: [[1, \"content\"], [1, \"is-bold\"], [1, \"seg\"], [1, \"blog_topic\"], [\"href\", \"https://www.pyinstaller.org/\", \"target\", \"_blank\"], [\"href\", \"../../../assets/static-pages/variegata-example3.html\", \"target\", \"_blank\"]],\n    template: function VariegataPost8Component_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"h2\", 1);\n        i0.ɵɵtext(2, \"March 31, 2021\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"p\");\n        i0.ɵɵtext(5, \"The main technologies used for this step include:\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"ul\")(7, \"li\");\n        i0.ɵɵtext(8, \"Python/Flask\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"li\");\n        i0.ɵɵtext(10, \"scikit-learn\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"li\");\n        i0.ɵɵtext(12, \"PyInstaller\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(13, \"div\", 2)(14, \"h3\", 3)(15, \"strong\");\n        i0.ɵɵtext(16, \"Search Engine\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(17, \"p\");\n        i0.ɵɵtext(18, \"Using the scikit-learn library, I was able to implement a basic search engine for the stored events. This engine uses the TF-IDF technique that many search engines use. With this, I am able to use the keywords generated from the inter-graph model discussed last week, and query the engine to find which events most closely match the keywords. We are finally generating full stories using all events available from our database! They are still a bit rough and definitely some fine tuning, but at least the final structure of the generator is pretty much working.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(19, \"div\", 2)(20, \"h3\", 3)(21, \"strong\");\n        i0.ɵɵtext(22, \"PyInstaller\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(23, \"p\");\n        i0.ɵɵtext(24, \"Because the generator is now using a much larger dataset and large files for the model and search engine vectorizer, my hosting server is having more and more difficulty properly running the generator as a web app. In order to avoid dealing with more tools to get it to work online, I have decided to bundle the application as a downloadable executable. This allows it to be more modular and to run much more smoothly. To do this, I used \");\n        i0.ɵɵelementStart(25, \"a\", 4);\n        i0.ɵɵtext(26, \"PyInstaller\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(27, \" . This tool basically wraps all of the needed data files, dependencies, and application code into one easy-to-use executable.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(28, \"p\");\n        i0.ɵɵtext(29, \"As always, getting things to work out of the box never happens, so I had to spend a bit of time getting PyInstaller to get along with my code. There were some issues getting certain dependencies to properly get packaged so that the executable could run. I kept running into odd errors that seemed unrelated to the tasks I was trying to accomplish (many of which others online have also experienced). I managed to find a newer development version that takes care of some of these, and got everything to work.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(30, \"div\", 2)(31, \"p\");\n        i0.ɵɵtext(32, \"View an \");\n        i0.ɵɵelementStart(33, \"a\", 5);\n        i0.ɵɵtext(34, \"example story\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(35, \" generated using this iteration.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(36, \"div\", 2)(37, \"h3\", 3)(38, \"strong\");\n        i0.ɵɵtext(39, \"Moving Forward\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(40, \"p\");\n        i0.ɵɵtext(41, \"As can be seen in the currently generated stories, there tend to be some repeated events due to keywords bouncing back and forth between each other. There is also the problem of some stories not going across different source stories, but rather all generated events being too closely related. I plan on looking into ways to avoid this, and to add more variety to what is created.\");\n        i0.ɵɵelementEnd()()();\n      }\n    }\n  });\n  return VariegataPost8Component;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}