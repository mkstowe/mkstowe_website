{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nexport let VariegataPost7Component = /*#__PURE__*/(() => {\n  class VariegataPost7Component {\n    constructor(titleService) {\n      this.titleService = titleService;\n      this.titleService.setTitle(\"Michael Stowe | Project Variegata\");\n    }\n    ngOnInit() {}\n  }\n  VariegataPost7Component.ɵfac = function VariegataPost7Component_Factory(t) {\n    return new (t || VariegataPost7Component)(i0.ɵɵdirectiveInject(i1.Title));\n  };\n  VariegataPost7Component.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: VariegataPost7Component,\n    selectors: [[\"app-variegata-post7\"]],\n    decls: 48,\n    vars: 0,\n    consts: [[1, \"content\"], [1, \"is-bold\"], [1, \"seg\"], [1, \"blog_topic\"], [1, \"blog_post\"]],\n    template: function VariegataPost7Component_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"h2\", 1);\n        i0.ɵɵtext(2, \"March 24, 2021\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"h3\", 3)(5, \"strong\");\n        i0.ɵɵtext(6, \"Progress So Far\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(7, \"p\");\n        i0.ɵɵtext(8, \"I successfully fixed the issues that I was experiencing last week (at least, as far as I can tell) and was able to continue improving the actual project. The main update was converting the node2vec model to use keywords extracted from events, rather than just the labels.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"p\");\n        i0.ɵɵtext(10, \"The main technologies used for this step include:\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"ul\")(12, \"li\");\n        i0.ɵɵtext(13, \"Python/Flask\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"li\");\n        i0.ɵɵtext(15, \"MySQL/MariaDB\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(16, \"li\");\n        i0.ɵɵtext(17, \"NetworkX\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(18, \"li\");\n        i0.ɵɵtext(19, \"node2vec\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(20, \"div\", 2)(21, \"h3\", 3)(22, \"strong\");\n        i0.ɵɵtext(23, \"Resolving Hosting Issues\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(24, \"p\");\n        i0.ɵɵtext(25, \"As discussed in last week's post, there were a whole lot of issues revolving around getting the necessary technologies to work on my web host's server. With the help of a couple of the technicians over at the web host, I was able to get those technologies properly installed and converted some of my code accordingly to be able to properly connect to my database via Python scripts. As far as I can tell, it is all working adequately well now!\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(26, \"div\", 2)(27, \"h3\", 3)(28, \"strong\");\n        i0.ɵɵtext(29, \"Keyword-Based Model\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(30, \"p\");\n        i0.ɵɵtext(31, \"Once all of the administrative stuff was taken care of, I got back to working on my actual project. The last prototype I discussed simply used the labels generated for each event to determine which events are similar. This method does successfully predict and embed events into our story graphs, but the problem is that it constrained embedded events to only the story that was currently being looked at.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(32, \"p\");\n        i0.ɵɵtext(33, \"To solve this issue, I first scrape the stories on the internet and save them to their own files. Next, I generate a graph for each story in a similar way as before, except using keywords. To do this, I generate a number of keywords for each event (in my initial tests I have been using five keywords for each). For each event that is connected to each other event, I create edges for each combination of keywords. Once each graph is generated, I add it to a larger \\\"master\\\" graph, which is a composition of each individual graph. Any time a keyword is added that already exists in the master, rather than creating a duplicate node it just adds all of the new edges to the existing node.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(34, \"p\");\n        i0.ɵɵtext(35, \"Once the master keyword graph is generated, I train a model using the node2vec algorithm just like before, and query this model each time a event is needed during our story generation.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(36, \"div\", 2)(37, \"h3\", 4)(38, \"strong\");\n        i0.ɵɵtext(39, \"Current Generated \\\"Stories\\\"\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(40, \"p\");\n        i0.ɵɵtext(41, \"In the current state of the generation system, rather than entire events being inserted it is just individual keywords. While this may seem like a step backwards since we no longer get entire stories, it is actually a much more robust system - especially because of the fact that we are able to create embeddings across every story in our database. The next step is to finish implementing the search engine system discussed before to be able to query events from our database using these keywords that are being returned.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(42, \"div\", 2)(43, \"h3\", 4)(44, \"strong\");\n        i0.ɵɵtext(45, \"Moving Forward\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(46, \"p\");\n        i0.ɵɵtext(47, \"The biggest task for this coming week is to get the search engine for events finished so that we can generate more complete stories instead of individual words. Another thing I plan on looking into is the variety of words. In its current state, the model has a tendency to bounce back and forth between the same words sometimes. This is especially true when a generated keyword is something very specific, so there's really only one place for the generator to go. I will be looking into ways to try to avoid getting stuck in a \\\"keyword loop\\\", and find a way to determine what is an acceptable number of repetitions for a given keyword.\");\n        i0.ɵɵelementEnd()()();\n      }\n    }\n  });\n  return VariegataPost7Component;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}